/**
 * Generated by orval v7.13.2 ðŸº
 * Do not edit manually.
 * YSHAI API
 * The YSHAI backend API documentation. This API manages posts, teams, media, AI generation, moderation, analytics, billing, and more.
 * OpenAPI spec version: 1.0
 */
export interface RegisterDto {
  /**
   * User email address
   * @minLength 5
   * @maxLength 50
   */
  email: string;
  /**
   * Password for authentication
   * @minLength 6
   * @maxLength 100
   */
  password: string;
  /**
   * Full name of the user
   * @minLength 2
   * @maxLength 100
   */
  name: string;
  /** Timezone of the user */
  timezone: string;
  /** Preferred time format of the user */
  timeFormat: string;
}

export interface RefreshTokenDto {
  /** The refresh token */
  refreshToken: string;
  /** The user ID associated with the refresh token */
  userId: number;
}

export interface UpdateUserDto {
  email: string;
  name: string;
}

export interface UpdatePreferencesDto {
  /** IANA timezone, e.g., America/New_York */
  timezone?: string;
  /** BCP 47 language tag, e.g., en or ar */
  language?: string;
  /** Locale for formatting, e.g., en-US or ar-EG */
  locale?: string;
  /** 12h or 24h clock format */
  timeFormat?: string;
}

/**
 * Status of the post
 */
export type CreatePostDtoStatus = typeof CreatePostDtoStatus[keyof typeof CreatePostDtoStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreatePostDtoStatus = {
  draft: 'draft',
  scheduled: 'scheduled',
  published: 'published',
  failed: 'failed',
  pending_approval: 'pending_approval',
} as const;

export interface CreatePostDto {
  /** Arabic content of the post */
  contentAr: string;
  /** English content of the post (optional) */
  contentEn?: string;
  /** Scheduled date and time for the post (ISO format) */
  scheduleAt: string;
  /** Status of the post */
  status?: CreatePostDtoStatus;
  /** Whether the post is part of a recurring schedule */
  isRecurring?: boolean;
  /** ID of the author (User) */
  authorId: number;
  /** ID of the team (optional) */
  teamId?: number;
  /** IDs of the social accounts to post to (optional, multi-target) */
  socialAccountIds?: number[];
  /** ID of the associated campaign (optional) */
  campaignId?: number;
  /** ID of the template used (optional) */
  templateId?: number;
}

export interface Post { [key: string]: unknown }

export interface BulkCreatePostsDto {
  posts: CreatePostDto[];
}

/**
 * Status
 */
export type RecurringPostDtoStatus = typeof RecurringPostDtoStatus[keyof typeof RecurringPostDtoStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RecurringPostDtoStatus = {
  draft: 'draft',
  scheduled: 'scheduled',
  published: 'published',
  failed: 'failed',
  pending_approval: 'pending_approval',
} as const;

export interface RecurringPostDto {
  /** Arabic content */
  contentAr: string;
  /** English content */
  contentEn?: string;
  /** First scheduled time (ISO) */
  scheduleAt: string;
  /** Status */
  status?: RecurringPostDtoStatus;
  /** Force recurring */
  isRecurring: boolean;
  /** Author ID */
  authorId: number;
  /** Team ID */
  teamId?: number;
  /** Social account IDs (multi-target) */
  socialAccountIds?: number[];
  /** Campaign ID */
  campaignId?: number;
  /** Template ID */
  templateId?: number;
}

export interface DraftPostDto {
  /** Arabic content */
  contentAr: string;
  /** English content */
  contentEn?: string;
  /** When you plan to publish this draft */
  scheduleAt: string;
  /** Author ID */
  authorId: number;
  /** Team ID */
  teamId?: number;
  /** Social account IDs (multi-target) */
  socialAccountIds?: number[];
  /** Campaign ID */
  campaignId?: number;
  /** Template ID */
  templateId?: number;
}

/**
 * Status
 */
export type UpdatePostDtoStatus = typeof UpdatePostDtoStatus[keyof typeof UpdatePostDtoStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UpdatePostDtoStatus = {
  draft: 'draft',
  scheduled: 'scheduled',
  published: 'published',
  failed: 'failed',
  pending_approval: 'pending_approval',
} as const;

export interface UpdatePostDto {
  /** Arabic content */
  contentAr?: string;
  /** English content */
  contentEn?: string;
  /** Scheduled date/time */
  scheduleAt?: string;
  /** Status */
  status?: UpdatePostDtoStatus;
  /** Is recurring? */
  isRecurring?: boolean;
  /** Team ID */
  teamId?: number;
  /** Social account IDs (multi-target) */
  socialAccountIds?: number[];
  /** Campaign ID */
  campaignId?: number;
  /** Template ID */
  templateId?: number;
}

export interface ReschedulePostDto {
  /** New scheduled date/time */
  scheduleAt: string;
}

export type MediaResponseDtoType = typeof MediaResponseDtoType[keyof typeof MediaResponseDtoType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MediaResponseDtoType = {
  image: 'image',
  video: 'video',
} as const;

export interface MediaResponseDto {
  id: number;
  url: string;
  type: MediaResponseDtoType;
  orderIndex: number;
  createdAt: string;
  /** Associated post ID (if any) */
  postId: number;
}

export interface CreateTeamDto {
  /** Name of the team */
  name: string;
}

/**
 * Role to assign to the invited member
 */
export type InviteMemberDtoRole = typeof InviteMemberDtoRole[keyof typeof InviteMemberDtoRole];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const InviteMemberDtoRole = {
  admin: 'admin',
  editor: 'editor',
  viewer: 'viewer',
} as const;

export interface InviteMemberDto {
  /** Email of the user to invite */
  email: string;
  /** Role to assign to the invited member */
  role: InviteMemberDtoRole;
}

/**
 * New role for the team member
 */
export type UpdateMemberRoleDtoRole = typeof UpdateMemberRoleDtoRole[keyof typeof UpdateMemberRoleDtoRole];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UpdateMemberRoleDtoRole = {
  admin: 'admin',
  editor: 'editor',
  viewer: 'viewer',
} as const;

export interface UpdateMemberRoleDto {
  /** New role for the team member */
  role: UpdateMemberRoleDtoRole;
}

export interface ModerateTextDto {
  /**
   * Arabic text to moderate
   * @maxLength 5000
   */
  text: string;
  /** Related post ID */
  postId: number;
}

export type ModerationResultProvider = typeof ModerationResultProvider[keyof typeof ModerationResultProvider];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ModerationResultProvider = {
  gemini: 'gemini',
  custom: 'custom',
} as const;

export type ModerationResultVerdict = typeof ModerationResultVerdict[keyof typeof ModerationResultVerdict];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ModerationResultVerdict = {
  allowed: 'allowed',
  flagged: 'flagged',
  blocked: 'blocked',
} as const;

/**
 * Raw moderation details
 */
export type ModerationResultDetails = { [key: string]: unknown };

export type ModerationResultCheckedAt = { [key: string]: unknown };

export interface ModerationResult {
  /** Associated post */
  post: Post;
  provider: ModerationResultProvider;
  verdict: ModerationResultVerdict;
  /** Raw moderation details */
  details?: ModerationResultDetails;
  checkedAt: ModerationResultCheckedAt;
}

export interface ModerateImageDto {
  /** Publicly accessible image URL to moderate */
  imageUrl: string;
  /** Related post ID */
  postId: number;
}

export interface ModerateVideoDto {
  /** Publicly accessible video URL to moderate */
  videoUrl: string;
  /** Related post ID */
  postId: number;
}

export interface PostInsightsDto {
  postId: number;
  impressions: number;
  clicks: number;
  likes: number;
  comments: number;
  shares: number;
  fetchedAt: string;
}

export interface AccountInsightsDto {
  accountId: number;
  totalPosts: number;
  totalImpressions: number;
  totalClicks: number;
  totalEngagements: number;
}

export interface CampaignInsightsDto {
  campaignId: number;
  posts: number;
  impressions: number;
  clicks: number;
  engagements: number;
}

/**
 * Number of captions to generate
 */
export type GenerateCaptionDtoCount = { [key: string]: unknown };

export interface GenerateCaptionDto {
  /** Prompt text for caption generation */
  prompt: string;
  /** Tone of the caption */
  tone?: string;
  /** Number of captions to generate */
  count: GenerateCaptionDtoCount;
}

/**
 * Number of hashtags to generate
 */
export type GenerateHashtagsDtoCount = { [key: string]: unknown };

export interface GenerateHashtagsDto {
  /** Text to generate hashtags for */
  text: string;
  /** Number of hashtags to generate */
  count: GenerateHashtagsDtoCount;
}

export interface GenerateAltTextDto {
  /** Image URL for alt text generation */
  imageUrl: string;
  /** Optional context for the image */
  context?: string;
}

export type LinkAccountWithTokensDtoProvider = typeof LinkAccountWithTokensDtoProvider[keyof typeof LinkAccountWithTokensDtoProvider];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const LinkAccountWithTokensDtoProvider = {
  x: 'x',
  instagram: 'instagram',
  linkedin: 'linkedin',
  tiktok: 'tiktok',
} as const;

export interface LinkAccountWithTokensDto {
  provider: LinkAccountWithTokensDtoProvider;
  providerAccountId: string;
  /** Short-lived access token from the provider */
  accessToken?: string;
  /** Long-lived refresh token from the provider */
  refreshToken?: string;
  /** Access token expiration (ISO 8601) */
  expiresAt?: string;
}

export type CreateWebhookDtoEvent = typeof CreateWebhookDtoEvent[keyof typeof CreateWebhookDtoEvent];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreateWebhookDtoEvent = {
  postpublished: 'post.published',
  postfailed: 'post.failed',
  accountdisconnected: 'account.disconnected',
} as const;

export interface CreateWebhookDto {
  /** HTTPS endpoint to receive events */
  url: string;
  event: CreateWebhookDtoEvent;
  /** Shared secret to sign webhook payloads */
  secret: string;
}

export interface SubscribeDto {
  /** Plan ID to subscribe to */
  planId: number;
  /** Payment method token or identifier */
  paymentMethod: string;
  /** Optional coupon code */
  couponCode?: string;
}

export type AssignRoleDtoRole = typeof AssignRoleDtoRole[keyof typeof AssignRoleDtoRole];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AssignRoleDtoRole = {
  user: 'user',
  admin: 'admin',
} as const;

export interface AssignRoleDto {
  role: AssignRoleDtoRole;
}

export type AuthControllerVerifyEmailParams = {
/**
 * Verification token from email
 */
token: string;
};

export type AuthControllerResendVerificationBody = {
  email: string;
};

export type AuthControllerLoginBody = {
  /**
   * @minLength 5
   * @maxLength 50
   */
  email: string;
  /**
   * @minLength 6
   * @maxLength 100
   */
  password: string;
};

export type AuthControllerForgotPasswordBody = {
  /**
   * @minLength 5
   * @maxLength 50
   */
  email: string;
};

export type AuthControllerResetPasswordBody = {
  token: string;
  /** @minLength 6 */
  newPassword: string;
};

export type PostsControllerBulkCreateFromCsvBody = {
  /** CSV with headers: contentAr,contentEn?,scheduleAt,authorId,teamId?,socialAccountIds?(comma-separated),campaignId?,templateId?,status?,isRecurring? */
  file: Blob;
};

export type MediaControllerUploadBody = {
  /** The media file (image or video) */
  file?: Blob;
  /** Optional: ID of the post to associate with */
  postId?: number;
};

export type WebhooksControllerDeliveriesParams = {
/**
 * @minimum 1
 */
page?: number;
/**
 * @minimum 1
 * @maximum 100
 */
limit?: number;
};

/**
 * @summary Register a new user
 */
export type authControllerRegisterResponse201 = {
  data: void
  status: 201
}

export type authControllerRegisterResponse400 = {
  data: void
  status: 400
}
    
export type authControllerRegisterResponseSuccess = (authControllerRegisterResponse201) & {
  headers: Headers;
};
export type authControllerRegisterResponseError = (authControllerRegisterResponse400) & {
  headers: Headers;
};

export type authControllerRegisterResponse = (authControllerRegisterResponseSuccess | authControllerRegisterResponseError)

export const getAuthControllerRegisterUrl = () => {


  

  return `/auth/register`
}

export const authControllerRegister = async (registerDto: RegisterDto, options?: RequestInit): Promise<authControllerRegisterResponse> => {
  
  const res = await fetch(getAuthControllerRegisterUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      registerDto,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: authControllerRegisterResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as authControllerRegisterResponse
}



/**
 * @summary Verify user email via token
 */
export type authControllerVerifyEmailResponse200 = {
  data: void
  status: 200
}

export type authControllerVerifyEmailResponse400 = {
  data: void
  status: 400
}
    
export type authControllerVerifyEmailResponseSuccess = (authControllerVerifyEmailResponse200) & {
  headers: Headers;
};
export type authControllerVerifyEmailResponseError = (authControllerVerifyEmailResponse400) & {
  headers: Headers;
};

export type authControllerVerifyEmailResponse = (authControllerVerifyEmailResponseSuccess | authControllerVerifyEmailResponseError)

export const getAuthControllerVerifyEmailUrl = (params: AuthControllerVerifyEmailParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/auth/verify?${stringifiedParams}` : `/auth/verify`
}

export const authControllerVerifyEmail = async (params: AuthControllerVerifyEmailParams, options?: RequestInit): Promise<authControllerVerifyEmailResponse> => {
  
  const res = await fetch(getAuthControllerVerifyEmailUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: authControllerVerifyEmailResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as authControllerVerifyEmailResponse
}



/**
 * @summary Resend email verification link
 */
export type authControllerResendVerificationResponse200 = {
  data: void
  status: 200
}

export type authControllerResendVerificationResponse400 = {
  data: void
  status: 400
}
    
export type authControllerResendVerificationResponseSuccess = (authControllerResendVerificationResponse200) & {
  headers: Headers;
};
export type authControllerResendVerificationResponseError = (authControllerResendVerificationResponse400) & {
  headers: Headers;
};

export type authControllerResendVerificationResponse = (authControllerResendVerificationResponseSuccess | authControllerResendVerificationResponseError)

export const getAuthControllerResendVerificationUrl = () => {


  

  return `/auth/resend-verification`
}

export const authControllerResendVerification = async (authControllerResendVerificationBody: AuthControllerResendVerificationBody, options?: RequestInit): Promise<authControllerResendVerificationResponse> => {
  
  const res = await fetch(getAuthControllerResendVerificationUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      authControllerResendVerificationBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: authControllerResendVerificationResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as authControllerResendVerificationResponse
}



/**
 * @summary Login
 */
export type authControllerLoginResponse201 = {
  data: void
  status: 201
}

export type authControllerLoginResponse401 = {
  data: void
  status: 401
}
    
export type authControllerLoginResponseSuccess = (authControllerLoginResponse201) & {
  headers: Headers;
};
export type authControllerLoginResponseError = (authControllerLoginResponse401) & {
  headers: Headers;
};

export type authControllerLoginResponse = (authControllerLoginResponseSuccess | authControllerLoginResponseError)

export const getAuthControllerLoginUrl = () => {


  

  return `/auth/login`
}

export const authControllerLogin = async (authControllerLoginBody: AuthControllerLoginBody, options?: RequestInit): Promise<authControllerLoginResponse> => {
  
  const res = await fetch(getAuthControllerLoginUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      authControllerLoginBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: authControllerLoginResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as authControllerLoginResponse
}



/**
 * @summary Logout
 */
export type authControllerLogoutResponse200 = {
  data: void
  status: 200
}

export type authControllerLogoutResponse401 = {
  data: void
  status: 401
}
    
export type authControllerLogoutResponseSuccess = (authControllerLogoutResponse200) & {
  headers: Headers;
};
export type authControllerLogoutResponseError = (authControllerLogoutResponse401) & {
  headers: Headers;
};

export type authControllerLogoutResponse = (authControllerLogoutResponseSuccess | authControllerLogoutResponseError)

export const getAuthControllerLogoutUrl = () => {


  

  return `/auth/logout`
}

export const authControllerLogout = async ( options?: RequestInit): Promise<authControllerLogoutResponse> => {
  
  const res = await fetch(getAuthControllerLogoutUrl(),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: authControllerLogoutResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as authControllerLogoutResponse
}



/**
 * @summary Forgot password
 */
export type authControllerForgotPasswordResponse200 = {
  data: void
  status: 200
}

export type authControllerForgotPasswordResponse400 = {
  data: void
  status: 400
}
    
export type authControllerForgotPasswordResponseSuccess = (authControllerForgotPasswordResponse200) & {
  headers: Headers;
};
export type authControllerForgotPasswordResponseError = (authControllerForgotPasswordResponse400) & {
  headers: Headers;
};

export type authControllerForgotPasswordResponse = (authControllerForgotPasswordResponseSuccess | authControllerForgotPasswordResponseError)

export const getAuthControllerForgotPasswordUrl = () => {


  

  return `/auth/forgot-password`
}

export const authControllerForgotPassword = async (authControllerForgotPasswordBody: AuthControllerForgotPasswordBody, options?: RequestInit): Promise<authControllerForgotPasswordResponse> => {
  
  const res = await fetch(getAuthControllerForgotPasswordUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      authControllerForgotPasswordBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: authControllerForgotPasswordResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as authControllerForgotPasswordResponse
}



/**
 * @summary Reset password
 */
export type authControllerResetPasswordResponse200 = {
  data: void
  status: 200
}

export type authControllerResetPasswordResponse400 = {
  data: void
  status: 400
}
    
export type authControllerResetPasswordResponseSuccess = (authControllerResetPasswordResponse200) & {
  headers: Headers;
};
export type authControllerResetPasswordResponseError = (authControllerResetPasswordResponse400) & {
  headers: Headers;
};

export type authControllerResetPasswordResponse = (authControllerResetPasswordResponseSuccess | authControllerResetPasswordResponseError)

export const getAuthControllerResetPasswordUrl = () => {


  

  return `/auth/reset-password`
}

export const authControllerResetPassword = async (authControllerResetPasswordBody: AuthControllerResetPasswordBody, options?: RequestInit): Promise<authControllerResetPasswordResponse> => {
  
  const res = await fetch(getAuthControllerResetPasswordUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      authControllerResetPasswordBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: authControllerResetPasswordResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as authControllerResetPasswordResponse
}



/**
 * @summary Get current user using JWT
 */
export type usersControllerGetProfileResponse200 = {
  data: void
  status: 200
}

export type usersControllerGetProfileResponse404 = {
  data: void
  status: 404
}
    
export type usersControllerGetProfileResponseSuccess = (usersControllerGetProfileResponse200) & {
  headers: Headers;
};
export type usersControllerGetProfileResponseError = (usersControllerGetProfileResponse404) & {
  headers: Headers;
};

export type usersControllerGetProfileResponse = (usersControllerGetProfileResponseSuccess | usersControllerGetProfileResponseError)

export const getUsersControllerGetProfileUrl = () => {


  

  return `/users/me`
}

export const usersControllerGetProfile = async ( options?: RequestInit): Promise<usersControllerGetProfileResponse> => {
  
  const res = await fetch(getUsersControllerGetProfileUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: usersControllerGetProfileResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as usersControllerGetProfileResponse
}



/**
 * @summary Update current user using JWT
 */
export type usersControllerUpdateProfileResponse200 = {
  data: void
  status: 200
}

export type usersControllerUpdateProfileResponse404 = {
  data: void
  status: 404
}
    
export type usersControllerUpdateProfileResponseSuccess = (usersControllerUpdateProfileResponse200) & {
  headers: Headers;
};
export type usersControllerUpdateProfileResponseError = (usersControllerUpdateProfileResponse404) & {
  headers: Headers;
};

export type usersControllerUpdateProfileResponse = (usersControllerUpdateProfileResponseSuccess | usersControllerUpdateProfileResponseError)

export const getUsersControllerUpdateProfileUrl = () => {


  

  return `/users/me`
}

export const usersControllerUpdateProfile = async (updateUserDto: UpdateUserDto, options?: RequestInit): Promise<usersControllerUpdateProfileResponse> => {
  
  const res = await fetch(getUsersControllerUpdateProfileUrl(),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      updateUserDto,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: usersControllerUpdateProfileResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as usersControllerUpdateProfileResponse
}



/**
 * @summary Update current user preferences using JWT
 */
export type usersControllerUpdatePreferencesResponse200 = {
  data: void
  status: 200
}
    
export type usersControllerUpdatePreferencesResponseSuccess = (usersControllerUpdatePreferencesResponse200) & {
  headers: Headers;
};
;

export type usersControllerUpdatePreferencesResponse = (usersControllerUpdatePreferencesResponseSuccess)

export const getUsersControllerUpdatePreferencesUrl = () => {


  

  return `/users/me/preferences`
}

export const usersControllerUpdatePreferences = async (updatePreferencesDto: UpdatePreferencesDto, options?: RequestInit): Promise<usersControllerUpdatePreferencesResponse> => {
  
  const res = await fetch(getUsersControllerUpdatePreferencesUrl(),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      updatePreferencesDto,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: usersControllerUpdatePreferencesResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as usersControllerUpdatePreferencesResponse
}



/**
 * @summary Create a new post
 */
export type postsControllerCreateResponse201 = {
  data: Post
  status: 201
}

export type postsControllerCreateResponse404 = {
  data: void
  status: 404
}
    
export type postsControllerCreateResponseSuccess = (postsControllerCreateResponse201) & {
  headers: Headers;
};
export type postsControllerCreateResponseError = (postsControllerCreateResponse404) & {
  headers: Headers;
};

export type postsControllerCreateResponse = (postsControllerCreateResponseSuccess | postsControllerCreateResponseError)

export const getPostsControllerCreateUrl = () => {


  

  return `/posts`
}

export const postsControllerCreate = async (createPostDto: CreatePostDto, options?: RequestInit): Promise<postsControllerCreateResponse> => {
  
  const res = await fetch(getPostsControllerCreateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createPostDto,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: postsControllerCreateResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as postsControllerCreateResponse
}



/**
 * @summary Bulk create posts
 */
export type postsControllerBulkCreateResponse201 = {
  data: Post[]
  status: 201
}
    
export type postsControllerBulkCreateResponseSuccess = (postsControllerBulkCreateResponse201) & {
  headers: Headers;
};
;

export type postsControllerBulkCreateResponse = (postsControllerBulkCreateResponseSuccess)

export const getPostsControllerBulkCreateUrl = () => {


  

  return `/posts/bulk`
}

export const postsControllerBulkCreate = async (bulkCreatePostsDto: BulkCreatePostsDto, options?: RequestInit): Promise<postsControllerBulkCreateResponse> => {
  
  const res = await fetch(getPostsControllerBulkCreateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      bulkCreatePostsDto,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: postsControllerBulkCreateResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as postsControllerBulkCreateResponse
}



/**
 * @summary Bulk create posts from CSV upload
 */
export type postsControllerBulkCreateFromCsvResponse201 = {
  data: Post[]
  status: 201
}
    
export type postsControllerBulkCreateFromCsvResponseSuccess = (postsControllerBulkCreateFromCsvResponse201) & {
  headers: Headers;
};
;

export type postsControllerBulkCreateFromCsvResponse = (postsControllerBulkCreateFromCsvResponseSuccess)

export const getPostsControllerBulkCreateFromCsvUrl = () => {


  

  return `/posts/bulk/csv`
}

export const postsControllerBulkCreateFromCsv = async (postsControllerBulkCreateFromCsvBody: PostsControllerBulkCreateFromCsvBody, options?: RequestInit): Promise<postsControllerBulkCreateFromCsvResponse> => {
    const formData = new FormData();
formData.append(`file`, postsControllerBulkCreateFromCsvBody.file)

  const res = await fetch(getPostsControllerBulkCreateFromCsvUrl(),
  {      
    ...options,
    method: 'POST'
    ,
    body: 
      formData,
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: postsControllerBulkCreateFromCsvResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as postsControllerBulkCreateFromCsvResponse
}



/**
 * @summary Create a recurring post
 */
export type postsControllerCreateRecurringResponse201 = {
  data: Post
  status: 201
}
    
export type postsControllerCreateRecurringResponseSuccess = (postsControllerCreateRecurringResponse201) & {
  headers: Headers;
};
;

export type postsControllerCreateRecurringResponse = (postsControllerCreateRecurringResponseSuccess)

export const getPostsControllerCreateRecurringUrl = () => {


  

  return `/posts/recurring`
}

export const postsControllerCreateRecurring = async (recurringPostDto: RecurringPostDto, options?: RequestInit): Promise<postsControllerCreateRecurringResponse> => {
  
  const res = await fetch(getPostsControllerCreateRecurringUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      recurringPostDto,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: postsControllerCreateRecurringResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as postsControllerCreateRecurringResponse
}



/**
 * @summary Create a draft post
 */
export type postsControllerCreateDraftResponse201 = {
  data: Post
  status: 201
}
    
export type postsControllerCreateDraftResponseSuccess = (postsControllerCreateDraftResponse201) & {
  headers: Headers;
};
;

export type postsControllerCreateDraftResponse = (postsControllerCreateDraftResponseSuccess)

export const getPostsControllerCreateDraftUrl = () => {


  

  return `/posts/draft`
}

export const postsControllerCreateDraft = async (draftPostDto: DraftPostDto, options?: RequestInit): Promise<postsControllerCreateDraftResponse> => {
  
  const res = await fetch(getPostsControllerCreateDraftUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      draftPostDto,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: postsControllerCreateDraftResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as postsControllerCreateDraftResponse
}



/**
 * @summary Update an existing post
 */
export type postsControllerUpdateResponse200 = {
  data: Post
  status: 200
}

export type postsControllerUpdateResponse404 = {
  data: void
  status: 404
}
    
export type postsControllerUpdateResponseSuccess = (postsControllerUpdateResponse200) & {
  headers: Headers;
};
export type postsControllerUpdateResponseError = (postsControllerUpdateResponse404) & {
  headers: Headers;
};

export type postsControllerUpdateResponse = (postsControllerUpdateResponseSuccess | postsControllerUpdateResponseError)

export const getPostsControllerUpdateUrl = (id: number,) => {


  

  return `/posts/${id}`
}

export const postsControllerUpdate = async (id: number,
    updatePostDto: UpdatePostDto, options?: RequestInit): Promise<postsControllerUpdateResponse> => {
  
  const res = await fetch(getPostsControllerUpdateUrl(id),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      updatePostDto,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: postsControllerUpdateResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as postsControllerUpdateResponse
}



/**
 * @summary Delete a post (soft delete)
 */
export type postsControllerRemoveResponse200 = {
  data: void
  status: 200
}

export type postsControllerRemoveResponse404 = {
  data: void
  status: 404
}
    
export type postsControllerRemoveResponseSuccess = (postsControllerRemoveResponse200) & {
  headers: Headers;
};
export type postsControllerRemoveResponseError = (postsControllerRemoveResponse404) & {
  headers: Headers;
};

export type postsControllerRemoveResponse = (postsControllerRemoveResponseSuccess | postsControllerRemoveResponseError)

export const getPostsControllerRemoveUrl = (id: number,) => {


  

  return `/posts/${id}`
}

export const postsControllerRemove = async (id: number, options?: RequestInit): Promise<postsControllerRemoveResponse> => {
  
  const res = await fetch(getPostsControllerRemoveUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: postsControllerRemoveResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as postsControllerRemoveResponse
}



/**
 * @summary Reschedule a post
 */
export type postsControllerRescheduleResponse200 = {
  data: Post
  status: 200
}
    
export type postsControllerRescheduleResponseSuccess = (postsControllerRescheduleResponse200) & {
  headers: Headers;
};
;

export type postsControllerRescheduleResponse = (postsControllerRescheduleResponseSuccess)

export const getPostsControllerRescheduleUrl = (id: number,) => {


  

  return `/posts/${id}/reschedule`
}

export const postsControllerReschedule = async (id: number,
    reschedulePostDto: ReschedulePostDto, options?: RequestInit): Promise<postsControllerRescheduleResponse> => {
  
  const res = await fetch(getPostsControllerRescheduleUrl(id),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      reschedulePostDto,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: postsControllerRescheduleResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as postsControllerRescheduleResponse
}



/**
 * @summary Publish a post immediately (enqueue job)
 */
export type postsControllerPublishNowResponse200 = {
  data: Post
  status: 200
}
    
export type postsControllerPublishNowResponseSuccess = (postsControllerPublishNowResponse200) & {
  headers: Headers;
};
;

export type postsControllerPublishNowResponse = (postsControllerPublishNowResponseSuccess)

export const getPostsControllerPublishNowUrl = (id: number,) => {


  

  return `/posts/${id}/publish`
}

export const postsControllerPublishNow = async (id: number, options?: RequestInit): Promise<postsControllerPublishNowResponse> => {
  
  const res = await fetch(getPostsControllerPublishNowUrl(id),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: postsControllerPublishNowResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as postsControllerPublishNowResponse
}



/**
 * @summary Get post status
 */
export type postsControllerStatusGetResponse200 = {
  data: void
  status: 200
}
    
export type postsControllerStatusGetResponseSuccess = (postsControllerStatusGetResponse200) & {
  headers: Headers;
};
;

export type postsControllerStatusGetResponse = (postsControllerStatusGetResponseSuccess)

export const getPostsControllerStatusGetUrl = (id: number,) => {


  

  return `/posts/${id}/status`
}

export const postsControllerStatusGet = async (id: number, options?: RequestInit): Promise<postsControllerStatusGetResponse> => {
  
  const res = await fetch(getPostsControllerStatusGetUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: postsControllerStatusGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as postsControllerStatusGetResponse
}



/**
 * @summary Upload a media file (image or video) to Cloudinary
 */
export type mediaControllerUploadResponse201 = {
  data: MediaResponseDto
  status: 201
}
    
export type mediaControllerUploadResponseSuccess = (mediaControllerUploadResponse201) & {
  headers: Headers;
};
;

export type mediaControllerUploadResponse = (mediaControllerUploadResponseSuccess)

export const getMediaControllerUploadUrl = () => {


  

  return `/media`
}

export const mediaControllerUpload = async (mediaControllerUploadBody: MediaControllerUploadBody, options?: RequestInit): Promise<mediaControllerUploadResponse> => {
    const formData = new FormData();
if(mediaControllerUploadBody.file !== undefined) {
 formData.append(`file`, mediaControllerUploadBody.file)
 }
if(mediaControllerUploadBody.postId !== undefined) {
 formData.append(`postId`, mediaControllerUploadBody.postId.toString())
 }

  const res = await fetch(getMediaControllerUploadUrl(),
  {      
    ...options,
    method: 'POST'
    ,
    body: 
      formData,
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: mediaControllerUploadResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as mediaControllerUploadResponse
}



/**
 * @summary List all uploaded media
 */
export type mediaControllerFindAllResponse200 = {
  data: MediaResponseDto[]
  status: 200
}
    
export type mediaControllerFindAllResponseSuccess = (mediaControllerFindAllResponse200) & {
  headers: Headers;
};
;

export type mediaControllerFindAllResponse = (mediaControllerFindAllResponseSuccess)

export const getMediaControllerFindAllUrl = () => {


  

  return `/media`
}

export const mediaControllerFindAll = async ( options?: RequestInit): Promise<mediaControllerFindAllResponse> => {
  
  const res = await fetch(getMediaControllerFindAllUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: mediaControllerFindAllResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as mediaControllerFindAllResponse
}



/**
 * @summary Delete a media file from Cloudinary and database
 */
export type mediaControllerRemoveResponse200 = {
  data: void
  status: 200
}

export type mediaControllerRemoveResponse404 = {
  data: void
  status: 404
}
    
export type mediaControllerRemoveResponseSuccess = (mediaControllerRemoveResponse200) & {
  headers: Headers;
};
export type mediaControllerRemoveResponseError = (mediaControllerRemoveResponse404) & {
  headers: Headers;
};

export type mediaControllerRemoveResponse = (mediaControllerRemoveResponseSuccess | mediaControllerRemoveResponseError)

export const getMediaControllerRemoveUrl = (id: number,) => {


  

  return `/media/${id}`
}

export const mediaControllerRemove = async (id: number, options?: RequestInit): Promise<mediaControllerRemoveResponse> => {
  
  const res = await fetch(getMediaControllerRemoveUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: mediaControllerRemoveResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as mediaControllerRemoveResponse
}



/**
 * @summary Create a new team
 */
export type teamsControllerCreateResponse201 = {
  data: void
  status: 201
}
    
export type teamsControllerCreateResponseSuccess = (teamsControllerCreateResponse201) & {
  headers: Headers;
};
;

export type teamsControllerCreateResponse = (teamsControllerCreateResponseSuccess)

export const getTeamsControllerCreateUrl = () => {


  

  return `/teams`
}

export const teamsControllerCreate = async (createTeamDto: CreateTeamDto, options?: RequestInit): Promise<teamsControllerCreateResponse> => {
  
  const res = await fetch(getTeamsControllerCreateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createTeamDto,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: teamsControllerCreateResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as teamsControllerCreateResponse
}



/**
 * @summary Invite a member to the team
 */
export type teamsControllerInviteMemberResponse200 = {
  data: void
  status: 200
}
    
export type teamsControllerInviteMemberResponseSuccess = (teamsControllerInviteMemberResponse200) & {
  headers: Headers;
};
;

export type teamsControllerInviteMemberResponse = (teamsControllerInviteMemberResponseSuccess)

export const getTeamsControllerInviteMemberUrl = (teamId: number,) => {


  

  return `/teams/${teamId}/invite`
}

export const teamsControllerInviteMember = async (teamId: number,
    inviteMemberDto: InviteMemberDto, options?: RequestInit): Promise<teamsControllerInviteMemberResponse> => {
  
  const res = await fetch(getTeamsControllerInviteMemberUrl(teamId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      inviteMemberDto,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: teamsControllerInviteMemberResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as teamsControllerInviteMemberResponse
}



/**
 * @summary Update a team memberâ€™s role
 */
export type teamsControllerUpdateMemberRoleResponse200 = {
  data: void
  status: 200
}
    
export type teamsControllerUpdateMemberRoleResponseSuccess = (teamsControllerUpdateMemberRoleResponse200) & {
  headers: Headers;
};
;

export type teamsControllerUpdateMemberRoleResponse = (teamsControllerUpdateMemberRoleResponseSuccess)

export const getTeamsControllerUpdateMemberRoleUrl = (teamId: number,
    memberId: number,) => {


  

  return `/teams/${teamId}/members/${memberId}`
}

export const teamsControllerUpdateMemberRole = async (teamId: number,
    memberId: number,
    updateMemberRoleDto: UpdateMemberRoleDto, options?: RequestInit): Promise<teamsControllerUpdateMemberRoleResponse> => {
  
  const res = await fetch(getTeamsControllerUpdateMemberRoleUrl(teamId,memberId),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      updateMemberRoleDto,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: teamsControllerUpdateMemberRoleResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as teamsControllerUpdateMemberRoleResponse
}



/**
 * @summary Remove a member from the team
 */
export type teamsControllerRemoveMemberResponse200 = {
  data: void
  status: 200
}
    
export type teamsControllerRemoveMemberResponseSuccess = (teamsControllerRemoveMemberResponse200) & {
  headers: Headers;
};
;

export type teamsControllerRemoveMemberResponse = (teamsControllerRemoveMemberResponseSuccess)

export const getTeamsControllerRemoveMemberUrl = (teamId: number,
    memberId: number,) => {


  

  return `/teams/${teamId}/members/${memberId}`
}

export const teamsControllerRemoveMember = async (teamId: number,
    memberId: number, options?: RequestInit): Promise<teamsControllerRemoveMemberResponse> => {
  
  const res = await fetch(getTeamsControllerRemoveMemberUrl(teamId,memberId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: teamsControllerRemoveMemberResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as teamsControllerRemoveMemberResponse
}



/**
 * @summary Approve a post for publishing
 */
export type teamsControllerApprovePostResponse201 = {
  data: void
  status: 201
}
    
export type teamsControllerApprovePostResponseSuccess = (teamsControllerApprovePostResponse201) & {
  headers: Headers;
};
;

export type teamsControllerApprovePostResponse = (teamsControllerApprovePostResponseSuccess)

export const getTeamsControllerApprovePostUrl = (teamId: number,
    postId: number,) => {


  

  return `/teams/${teamId}/posts/${postId}/approve`
}

export const teamsControllerApprovePost = async (teamId: number,
    postId: number, options?: RequestInit): Promise<teamsControllerApprovePostResponse> => {
  
  const res = await fetch(getTeamsControllerApprovePostUrl(teamId,postId),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: teamsControllerApprovePostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as teamsControllerApprovePostResponse
}



/**
 * @summary Reject a post
 */
export type teamsControllerRejectPostResponse201 = {
  data: void
  status: 201
}
    
export type teamsControllerRejectPostResponseSuccess = (teamsControllerRejectPostResponse201) & {
  headers: Headers;
};
;

export type teamsControllerRejectPostResponse = (teamsControllerRejectPostResponseSuccess)

export const getTeamsControllerRejectPostUrl = (teamId: number,
    postId: number,) => {


  

  return `/teams/${teamId}/posts/${postId}/reject`
}

export const teamsControllerRejectPost = async (teamId: number,
    postId: number, options?: RequestInit): Promise<teamsControllerRejectPostResponse> => {
  
  const res = await fetch(getTeamsControllerRejectPostUrl(teamId,postId),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: teamsControllerRejectPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as teamsControllerRejectPostResponse
}



/**
 * @summary List team audit logs
 */
export type teamsControllerListAuditLogsResponse200 = {
  data: void
  status: 200
}
    
export type teamsControllerListAuditLogsResponseSuccess = (teamsControllerListAuditLogsResponse200) & {
  headers: Headers;
};
;

export type teamsControllerListAuditLogsResponse = (teamsControllerListAuditLogsResponseSuccess)

export const getTeamsControllerListAuditLogsUrl = (teamId: number,) => {


  

  return `/teams/${teamId}/audit-logs`
}

export const teamsControllerListAuditLogs = async (teamId: number, options?: RequestInit): Promise<teamsControllerListAuditLogsResponse> => {
  
  const res = await fetch(getTeamsControllerListAuditLogsUrl(teamId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: teamsControllerListAuditLogsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as teamsControllerListAuditLogsResponse
}



/**
 * @summary Moderate Arabic text
 */
export type moderationControllerModerateTextResponse200 = {
  data: ModerationResult
  status: 200
}
    
export type moderationControllerModerateTextResponseSuccess = (moderationControllerModerateTextResponse200) & {
  headers: Headers;
};
;

export type moderationControllerModerateTextResponse = (moderationControllerModerateTextResponseSuccess)

export const getModerationControllerModerateTextUrl = () => {


  

  return `/moderation/text`
}

export const moderationControllerModerateText = async (moderateTextDto: ModerateTextDto, options?: RequestInit): Promise<moderationControllerModerateTextResponse> => {
  
  const res = await fetch(getModerationControllerModerateTextUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      moderateTextDto,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: moderationControllerModerateTextResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as moderationControllerModerateTextResponse
}



/**
 * @summary Moderate an image by URL
 */
export type moderationControllerModerateImageResponse200 = {
  data: ModerationResult
  status: 200
}
    
export type moderationControllerModerateImageResponseSuccess = (moderationControllerModerateImageResponse200) & {
  headers: Headers;
};
;

export type moderationControllerModerateImageResponse = (moderationControllerModerateImageResponseSuccess)

export const getModerationControllerModerateImageUrl = () => {


  

  return `/moderation/image`
}

export const moderationControllerModerateImage = async (moderateImageDto: ModerateImageDto, options?: RequestInit): Promise<moderationControllerModerateImageResponse> => {
  
  const res = await fetch(getModerationControllerModerateImageUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      moderateImageDto,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: moderationControllerModerateImageResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as moderationControllerModerateImageResponse
}



/**
 * @summary Moderate a video by URL
 */
export type moderationControllerModerateVideoResponse200 = {
  data: ModerationResult
  status: 200
}
    
export type moderationControllerModerateVideoResponseSuccess = (moderationControllerModerateVideoResponse200) & {
  headers: Headers;
};
;

export type moderationControllerModerateVideoResponse = (moderationControllerModerateVideoResponseSuccess)

export const getModerationControllerModerateVideoUrl = () => {


  

  return `/moderation/video`
}

export const moderationControllerModerateVideo = async (moderateVideoDto: ModerateVideoDto, options?: RequestInit): Promise<moderationControllerModerateVideoResponse> => {
  
  const res = await fetch(getModerationControllerModerateVideoUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      moderateVideoDto,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: moderationControllerModerateVideoResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as moderationControllerModerateVideoResponse
}



/**
 * @summary Fetch moderation reports
 */
export type moderationControllerGetReportsResponse200 = {
  data: ModerationResult[]
  status: 200
}
    
export type moderationControllerGetReportsResponseSuccess = (moderationControllerGetReportsResponse200) & {
  headers: Headers;
};
;

export type moderationControllerGetReportsResponse = (moderationControllerGetReportsResponseSuccess)

export const getModerationControllerGetReportsUrl = () => {


  

  return `/moderation/reports`
}

export const moderationControllerGetReports = async ( options?: RequestInit): Promise<moderationControllerGetReportsResponse> => {
  
  const res = await fetch(getModerationControllerGetReportsUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: moderationControllerGetReportsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as moderationControllerGetReportsResponse
}



/**
 * @summary Post Insights
 */
export type analyticsControllerGetPostInsightsResponse200 = {
  data: PostInsightsDto
  status: 200
}
    
export type analyticsControllerGetPostInsightsResponseSuccess = (analyticsControllerGetPostInsightsResponse200) & {
  headers: Headers;
};
;

export type analyticsControllerGetPostInsightsResponse = (analyticsControllerGetPostInsightsResponseSuccess)

export const getAnalyticsControllerGetPostInsightsUrl = (postId: number,) => {


  

  return `/analytics/posts/${postId}`
}

export const analyticsControllerGetPostInsights = async (postId: number, options?: RequestInit): Promise<analyticsControllerGetPostInsightsResponse> => {
  
  const res = await fetch(getAnalyticsControllerGetPostInsightsUrl(postId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: analyticsControllerGetPostInsightsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as analyticsControllerGetPostInsightsResponse
}



/**
 * @summary Account Insights
 */
export type analyticsControllerGetAccountInsightsResponse200 = {
  data: AccountInsightsDto
  status: 200
}
    
export type analyticsControllerGetAccountInsightsResponseSuccess = (analyticsControllerGetAccountInsightsResponse200) & {
  headers: Headers;
};
;

export type analyticsControllerGetAccountInsightsResponse = (analyticsControllerGetAccountInsightsResponseSuccess)

export const getAnalyticsControllerGetAccountInsightsUrl = (accountId: number,) => {


  

  return `/analytics/accounts/${accountId}`
}

export const analyticsControllerGetAccountInsights = async (accountId: number, options?: RequestInit): Promise<analyticsControllerGetAccountInsightsResponse> => {
  
  const res = await fetch(getAnalyticsControllerGetAccountInsightsUrl(accountId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: analyticsControllerGetAccountInsightsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as analyticsControllerGetAccountInsightsResponse
}



/**
 * @summary Campaign Insights
 */
export type analyticsControllerGetCampaignInsightsResponse200 = {
  data: CampaignInsightsDto
  status: 200
}
    
export type analyticsControllerGetCampaignInsightsResponseSuccess = (analyticsControllerGetCampaignInsightsResponse200) & {
  headers: Headers;
};
;

export type analyticsControllerGetCampaignInsightsResponse = (analyticsControllerGetCampaignInsightsResponseSuccess)

export const getAnalyticsControllerGetCampaignInsightsUrl = (campaignId: number,) => {


  

  return `/analytics/campaigns/${campaignId}`
}

export const analyticsControllerGetCampaignInsights = async (campaignId: number, options?: RequestInit): Promise<analyticsControllerGetCampaignInsightsResponse> => {
  
  const res = await fetch(getAnalyticsControllerGetCampaignInsightsUrl(campaignId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: analyticsControllerGetCampaignInsightsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as analyticsControllerGetCampaignInsightsResponse
}



/**
 * @summary Export report as CSV
 */
export type analyticsControllerExportCsvResponse200 = {
  data: void
  status: 200
}
    
export type analyticsControllerExportCsvResponseSuccess = (analyticsControllerExportCsvResponse200) & {
  headers: Headers;
};
;

export type analyticsControllerExportCsvResponse = (analyticsControllerExportCsvResponseSuccess)

export const getAnalyticsControllerExportCsvUrl = () => {


  

  return `/analytics/export/csv`
}

export const analyticsControllerExportCsv = async ( options?: RequestInit): Promise<analyticsControllerExportCsvResponse> => {
  
  const res = await fetch(getAnalyticsControllerExportCsvUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: analyticsControllerExportCsvResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as analyticsControllerExportCsvResponse
}



/**
 * @summary Export report as PDF
 */
export type analyticsControllerExportPdfResponse200 = {
  data: void
  status: 200
}
    
export type analyticsControllerExportPdfResponseSuccess = (analyticsControllerExportPdfResponse200) & {
  headers: Headers;
};
;

export type analyticsControllerExportPdfResponse = (analyticsControllerExportPdfResponseSuccess)

export const getAnalyticsControllerExportPdfUrl = () => {


  

  return `/analytics/export/pdf`
}

export const analyticsControllerExportPdf = async ( options?: RequestInit): Promise<analyticsControllerExportPdfResponse> => {
  
  const res = await fetch(getAnalyticsControllerExportPdfUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: analyticsControllerExportPdfResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as analyticsControllerExportPdfResponse
}



/**
 * @summary Generate social media caption
 */
export type aiControllerGenerateCaptionResponse201 = {
  data: void
  status: 201
}
    
export type aiControllerGenerateCaptionResponseSuccess = (aiControllerGenerateCaptionResponse201) & {
  headers: Headers;
};
;

export type aiControllerGenerateCaptionResponse = (aiControllerGenerateCaptionResponseSuccess)

export const getAiControllerGenerateCaptionUrl = () => {


  

  return `/ai/caption`
}

export const aiControllerGenerateCaption = async (generateCaptionDto: GenerateCaptionDto, options?: RequestInit): Promise<aiControllerGenerateCaptionResponse> => {
  
  const res = await fetch(getAiControllerGenerateCaptionUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      generateCaptionDto,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: aiControllerGenerateCaptionResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as aiControllerGenerateCaptionResponse
}



/**
 * @summary Generate hashtags for text
 */
export type aiControllerGenerateHashtagsResponse201 = {
  data: void
  status: 201
}
    
export type aiControllerGenerateHashtagsResponseSuccess = (aiControllerGenerateHashtagsResponse201) & {
  headers: Headers;
};
;

export type aiControllerGenerateHashtagsResponse = (aiControllerGenerateHashtagsResponseSuccess)

export const getAiControllerGenerateHashtagsUrl = () => {


  

  return `/ai/hashtags`
}

export const aiControllerGenerateHashtags = async (generateHashtagsDto: GenerateHashtagsDto, options?: RequestInit): Promise<aiControllerGenerateHashtagsResponse> => {
  
  const res = await fetch(getAiControllerGenerateHashtagsUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      generateHashtagsDto,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: aiControllerGenerateHashtagsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as aiControllerGenerateHashtagsResponse
}



/**
 * @summary Generate alternative text for image
 */
export type aiControllerGenerateAltTextResponse201 = {
  data: void
  status: 201
}
    
export type aiControllerGenerateAltTextResponseSuccess = (aiControllerGenerateAltTextResponse201) & {
  headers: Headers;
};
;

export type aiControllerGenerateAltTextResponse = (aiControllerGenerateAltTextResponseSuccess)

export const getAiControllerGenerateAltTextUrl = () => {


  

  return `/ai/alt-text`
}

export const aiControllerGenerateAltText = async (generateAltTextDto: GenerateAltTextDto, options?: RequestInit): Promise<aiControllerGenerateAltTextResponse> => {
  
  const res = await fetch(getAiControllerGenerateAltTextUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      generateAltTextDto,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: aiControllerGenerateAltTextResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as aiControllerGenerateAltTextResponse
}



/**
 * @summary Root
 */
export type metaControllerRootResponse200 = {
  data: void
  status: 200
}
    
export type metaControllerRootResponseSuccess = (metaControllerRootResponse200) & {
  headers: Headers;
};
;

export type metaControllerRootResponse = (metaControllerRootResponseSuccess)

export const getMetaControllerRootUrl = () => {


  

  return `/`
}

export const metaControllerRoot = async ( options?: RequestInit): Promise<metaControllerRootResponse> => {
  
  const res = await fetch(getMetaControllerRootUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: metaControllerRootResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as metaControllerRootResponse
}



/**
 * @summary Health Check
 */
export type metaControllerHealthResponse200 = {
  data: void
  status: 200
}
    
export type metaControllerHealthResponseSuccess = (metaControllerHealthResponse200) & {
  headers: Headers;
};
;

export type metaControllerHealthResponse = (metaControllerHealthResponseSuccess)

export const getMetaControllerHealthUrl = () => {


  

  return `/health`
}

export const metaControllerHealth = async ( options?: RequestInit): Promise<metaControllerHealthResponse> => {
  
  const res = await fetch(getMetaControllerHealthUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: metaControllerHealthResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as metaControllerHealthResponse
}



/**
 * @summary List Timezones
 */
export type metaControllerListTimezonesResponse200 = {
  data: void
  status: 200
}
    
export type metaControllerListTimezonesResponseSuccess = (metaControllerListTimezonesResponse200) & {
  headers: Headers;
};
;

export type metaControllerListTimezonesResponse = (metaControllerListTimezonesResponseSuccess)

export const getMetaControllerListTimezonesUrl = () => {


  

  return `/meta/timezones`
}

export const metaControllerListTimezones = async ( options?: RequestInit): Promise<metaControllerListTimezonesResponse> => {
  
  const res = await fetch(getMetaControllerListTimezonesUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: metaControllerListTimezonesResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as metaControllerListTimezonesResponse
}



/**
 * @summary List Locales
 */
export type metaControllerListLocalesResponse200 = {
  data: void
  status: 200
}
    
export type metaControllerListLocalesResponseSuccess = (metaControllerListLocalesResponse200) & {
  headers: Headers;
};
;

export type metaControllerListLocalesResponse = (metaControllerListLocalesResponseSuccess)

export const getMetaControllerListLocalesUrl = () => {


  

  return `/meta/locales`
}

export const metaControllerListLocales = async ( options?: RequestInit): Promise<metaControllerListLocalesResponse> => {
  
  const res = await fetch(getMetaControllerListLocalesUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: metaControllerListLocalesResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as metaControllerListLocalesResponse
}



/**
 * @summary Link Account
 */
export type accountsControllerLinkResponse201 = {
  data: void
  status: 201
}
    
export type accountsControllerLinkResponseSuccess = (accountsControllerLinkResponse201) & {
  headers: Headers;
};
;

export type accountsControllerLinkResponse = (accountsControllerLinkResponseSuccess)

export const getAccountsControllerLinkUrl = () => {


  

  return `/accounts`
}

export const accountsControllerLink = async (linkAccountWithTokensDto: LinkAccountWithTokensDto, options?: RequestInit): Promise<accountsControllerLinkResponse> => {
  
  const res = await fetch(getAccountsControllerLinkUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      linkAccountWithTokensDto,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: accountsControllerLinkResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as accountsControllerLinkResponse
}



/**
 * @summary Unlink Account
 */
export type accountsControllerUnlinkResponse200 = {
  data: void
  status: 200
}
    
export type accountsControllerUnlinkResponseSuccess = (accountsControllerUnlinkResponse200) & {
  headers: Headers;
};
;

export type accountsControllerUnlinkResponse = (accountsControllerUnlinkResponseSuccess)

export const getAccountsControllerUnlinkUrl = (accountId: number,) => {


  

  return `/accounts/${accountId}`
}

export const accountsControllerUnlink = async (accountId: number, options?: RequestInit): Promise<accountsControllerUnlinkResponse> => {
  
  const res = await fetch(getAccountsControllerUnlinkUrl(accountId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: accountsControllerUnlinkResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as accountsControllerUnlinkResponse
}



/**
 * @summary List notifications for current user
 */
export type notificationsControllerListResponse200 = {
  data: void
  status: 200
}
    
export type notificationsControllerListResponseSuccess = (notificationsControllerListResponse200) & {
  headers: Headers;
};
;

export type notificationsControllerListResponse = (notificationsControllerListResponseSuccess)

export const getNotificationsControllerListUrl = () => {


  

  return `/notifications`
}

export const notificationsControllerList = async ( options?: RequestInit): Promise<notificationsControllerListResponse> => {
  
  const res = await fetch(getNotificationsControllerListUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: notificationsControllerListResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as notificationsControllerListResponse
}



/**
 * @summary Mark notification as read
 */
export type notificationsControllerMarkReadResponse200 = {
  data: void
  status: 200
}
    
export type notificationsControllerMarkReadResponseSuccess = (notificationsControllerMarkReadResponse200) & {
  headers: Headers;
};
;

export type notificationsControllerMarkReadResponse = (notificationsControllerMarkReadResponseSuccess)

export const getNotificationsControllerMarkReadUrl = (notificationId: number,) => {


  

  return `/notifications/${notificationId}/read`
}

export const notificationsControllerMarkRead = async (notificationId: number, options?: RequestInit): Promise<notificationsControllerMarkReadResponse> => {
  
  const res = await fetch(getNotificationsControllerMarkReadUrl(notificationId),
  {      
    ...options,
    method: 'PATCH'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: notificationsControllerMarkReadResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as notificationsControllerMarkReadResponse
}



/**
 * @summary Get unread notifications count
 */
export type notificationsControllerUnreadCountResponse200 = {
  data: void
  status: 200
}
    
export type notificationsControllerUnreadCountResponseSuccess = (notificationsControllerUnreadCountResponse200) & {
  headers: Headers;
};
;

export type notificationsControllerUnreadCountResponse = (notificationsControllerUnreadCountResponseSuccess)

export const getNotificationsControllerUnreadCountUrl = () => {


  

  return `/notifications/unread-count`
}

export const notificationsControllerUnreadCount = async ( options?: RequestInit): Promise<notificationsControllerUnreadCountResponse> => {
  
  const res = await fetch(getNotificationsControllerUnreadCountUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: notificationsControllerUnreadCountResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as notificationsControllerUnreadCountResponse
}



/**
 * @summary Mark all notifications as read
 */
export type notificationsControllerMarkAllReadResponse200 = {
  data: void
  status: 200
}
    
export type notificationsControllerMarkAllReadResponseSuccess = (notificationsControllerMarkAllReadResponse200) & {
  headers: Headers;
};
;

export type notificationsControllerMarkAllReadResponse = (notificationsControllerMarkAllReadResponseSuccess)

export const getNotificationsControllerMarkAllReadUrl = () => {


  

  return `/notifications/mark-all-read`
}

export const notificationsControllerMarkAllRead = async ( options?: RequestInit): Promise<notificationsControllerMarkAllReadResponse> => {
  
  const res = await fetch(getNotificationsControllerMarkAllReadUrl(),
  {      
    ...options,
    method: 'PATCH'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: notificationsControllerMarkAllReadResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as notificationsControllerMarkAllReadResponse
}



/**
 * @summary Register webhook
 */
export type webhooksControllerRegisterResponse201 = {
  data: void
  status: 201
}
    
export type webhooksControllerRegisterResponseSuccess = (webhooksControllerRegisterResponse201) & {
  headers: Headers;
};
;

export type webhooksControllerRegisterResponse = (webhooksControllerRegisterResponseSuccess)

export const getWebhooksControllerRegisterUrl = () => {


  

  return `/webhooks`
}

export const webhooksControllerRegister = async (createWebhookDto: CreateWebhookDto, options?: RequestInit): Promise<webhooksControllerRegisterResponse> => {
  
  const res = await fetch(getWebhooksControllerRegisterUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createWebhookDto,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: webhooksControllerRegisterResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as webhooksControllerRegisterResponse
}



/**
 * @summary List webhooks
 */
export type webhooksControllerListResponse200 = {
  data: void
  status: 200
}
    
export type webhooksControllerListResponseSuccess = (webhooksControllerListResponse200) & {
  headers: Headers;
};
;

export type webhooksControllerListResponse = (webhooksControllerListResponseSuccess)

export const getWebhooksControllerListUrl = () => {


  

  return `/webhooks`
}

export const webhooksControllerList = async ( options?: RequestInit): Promise<webhooksControllerListResponse> => {
  
  const res = await fetch(getWebhooksControllerListUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: webhooksControllerListResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as webhooksControllerListResponse
}



/**
 * @summary Delete webhook
 */
export type webhooksControllerRemoveResponse200 = {
  data: void
  status: 200
}
    
export type webhooksControllerRemoveResponseSuccess = (webhooksControllerRemoveResponse200) & {
  headers: Headers;
};
;

export type webhooksControllerRemoveResponse = (webhooksControllerRemoveResponseSuccess)

export const getWebhooksControllerRemoveUrl = (webhookId: number,) => {


  

  return `/webhooks/${webhookId}`
}

export const webhooksControllerRemove = async (webhookId: number, options?: RequestInit): Promise<webhooksControllerRemoveResponse> => {
  
  const res = await fetch(getWebhooksControllerRemoveUrl(webhookId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: webhooksControllerRemoveResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as webhooksControllerRemoveResponse
}



/**
 * @summary List delivery attempts for a webhook
 */
export type webhooksControllerDeliveriesResponse200 = {
  data: void
  status: 200
}
    
export type webhooksControllerDeliveriesResponseSuccess = (webhooksControllerDeliveriesResponse200) & {
  headers: Headers;
};
;

export type webhooksControllerDeliveriesResponse = (webhooksControllerDeliveriesResponseSuccess)

export const getWebhooksControllerDeliveriesUrl = (webhookId: number,
    params?: WebhooksControllerDeliveriesParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/webhooks/${webhookId}/deliveries?${stringifiedParams}` : `/webhooks/${webhookId}/deliveries`
}

export const webhooksControllerDeliveries = async (webhookId: number,
    params?: WebhooksControllerDeliveriesParams, options?: RequestInit): Promise<webhooksControllerDeliveriesResponse> => {
  
  const res = await fetch(getWebhooksControllerDeliveriesUrl(webhookId,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: webhooksControllerDeliveriesResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as webhooksControllerDeliveriesResponse
}



/**
 * @summary List available plans
 */
export type billingControllerListPlansResponse200 = {
  data: void
  status: 200
}
    
export type billingControllerListPlansResponseSuccess = (billingControllerListPlansResponse200) & {
  headers: Headers;
};
;

export type billingControllerListPlansResponse = (billingControllerListPlansResponseSuccess)

export const getBillingControllerListPlansUrl = () => {


  

  return `/billing/plans`
}

export const billingControllerListPlans = async ( options?: RequestInit): Promise<billingControllerListPlansResponse> => {
  
  const res = await fetch(getBillingControllerListPlansUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: billingControllerListPlansResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as billingControllerListPlansResponse
}



/**
 * @summary Create or switch subscription
 */
export type billingControllerSubscribeResponse201 = {
  data: void
  status: 201
}
    
export type billingControllerSubscribeResponseSuccess = (billingControllerSubscribeResponse201) & {
  headers: Headers;
};
;

export type billingControllerSubscribeResponse = (billingControllerSubscribeResponseSuccess)

export const getBillingControllerSubscribeUrl = () => {


  

  return `/billing/subscribe`
}

export const billingControllerSubscribe = async (subscribeDto: SubscribeDto, options?: RequestInit): Promise<billingControllerSubscribeResponse> => {
  
  const res = await fetch(getBillingControllerSubscribeUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      subscribeDto,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: billingControllerSubscribeResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as billingControllerSubscribeResponse
}



/**
 * @summary Cancel current subscription
 */
export type billingControllerCancelResponse200 = {
  data: void
  status: 200
}
    
export type billingControllerCancelResponseSuccess = (billingControllerCancelResponse200) & {
  headers: Headers;
};
;

export type billingControllerCancelResponse = (billingControllerCancelResponseSuccess)

export const getBillingControllerCancelUrl = () => {


  

  return `/billing/cancel`
}

export const billingControllerCancel = async ( options?: RequestInit): Promise<billingControllerCancelResponse> => {
  
  const res = await fetch(getBillingControllerCancelUrl(),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: billingControllerCancelResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as billingControllerCancelResponse
}



/**
 * @summary List invoices for current user
 */
export type billingControllerInvoicesResponse200 = {
  data: void
  status: 200
}
    
export type billingControllerInvoicesResponseSuccess = (billingControllerInvoicesResponse200) & {
  headers: Headers;
};
;

export type billingControllerInvoicesResponse = (billingControllerInvoicesResponseSuccess)

export const getBillingControllerInvoicesUrl = () => {


  

  return `/billing/invoices`
}

export const billingControllerInvoices = async ( options?: RequestInit): Promise<billingControllerInvoicesResponse> => {
  
  const res = await fetch(getBillingControllerInvoicesUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: billingControllerInvoicesResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as billingControllerInvoicesResponse
}



/**
 * @summary Payment gateway callback
 */
export type billingControllerCallbackResponse201 = {
  data: void
  status: 201
}
    
export type billingControllerCallbackResponseSuccess = (billingControllerCallbackResponse201) & {
  headers: Headers;
};
;

export type billingControllerCallbackResponse = (billingControllerCallbackResponseSuccess)

export const getBillingControllerCallbackUrl = () => {


  

  return `/billing/callback`
}

export const billingControllerCallback = async ( options?: RequestInit): Promise<billingControllerCallbackResponse> => {
  
  const res = await fetch(getBillingControllerCallbackUrl(),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: billingControllerCallbackResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as billingControllerCallbackResponse
}



/**
 * @summary List users
 */
export type adminControllerListUsersResponse200 = {
  data: void
  status: 200
}
    
export type adminControllerListUsersResponseSuccess = (adminControllerListUsersResponse200) & {
  headers: Headers;
};
;

export type adminControllerListUsersResponse = (adminControllerListUsersResponseSuccess)

export const getAdminControllerListUsersUrl = () => {


  

  return `/admin/users`
}

export const adminControllerListUsers = async ( options?: RequestInit): Promise<adminControllerListUsersResponse> => {
  
  const res = await fetch(getAdminControllerListUsersUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: adminControllerListUsersResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as adminControllerListUsersResponse
}



/**
 * @summary Ban user
 */
export type adminControllerBanUserResponse201 = {
  data: void
  status: 201
}
    
export type adminControllerBanUserResponseSuccess = (adminControllerBanUserResponse201) & {
  headers: Headers;
};
;

export type adminControllerBanUserResponse = (adminControllerBanUserResponseSuccess)

export const getAdminControllerBanUserUrl = (id: number,) => {


  

  return `/admin/users/${id}/ban`
}

export const adminControllerBanUser = async (id: number, options?: RequestInit): Promise<adminControllerBanUserResponse> => {
  
  const res = await fetch(getAdminControllerBanUserUrl(id),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: adminControllerBanUserResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as adminControllerBanUserResponse
}



/**
 * @summary Assign role
 */
export type adminControllerAssignRoleResponse200 = {
  data: void
  status: 200
}
    
export type adminControllerAssignRoleResponseSuccess = (adminControllerAssignRoleResponse200) & {
  headers: Headers;
};
;

export type adminControllerAssignRoleResponse = (adminControllerAssignRoleResponseSuccess)

export const getAdminControllerAssignRoleUrl = (id: number,) => {


  

  return `/admin/users/${id}/role`
}

export const adminControllerAssignRole = async (id: number,
    assignRoleDto: AssignRoleDto, options?: RequestInit): Promise<adminControllerAssignRoleResponse> => {
  
  const res = await fetch(getAdminControllerAssignRoleUrl(id),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      assignRoleDto,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: adminControllerAssignRoleResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as adminControllerAssignRoleResponse
}



/**
 * @summary Audit logs
 */
export type adminControllerAuditLogsResponse200 = {
  data: void
  status: 200
}
    
export type adminControllerAuditLogsResponseSuccess = (adminControllerAuditLogsResponse200) & {
  headers: Headers;
};
;

export type adminControllerAuditLogsResponse = (adminControllerAuditLogsResponseSuccess)

export const getAdminControllerAuditLogsUrl = () => {


  

  return `/admin/audit-logs`
}

export const adminControllerAuditLogs = async ( options?: RequestInit): Promise<adminControllerAuditLogsResponse> => {
  
  const res = await fetch(getAdminControllerAuditLogsUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: adminControllerAuditLogsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as adminControllerAuditLogsResponse
}
